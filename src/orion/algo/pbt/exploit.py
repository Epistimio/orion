import numpy

from orion.core.utils import GenericFactory


class BaseExploit:
    def __init__(self):
        pass

    def __call__(self, rng, trial, lineages):
        pass

    @property
    def configuration(self):
        return dict(of_type=self.__class__.__name__.lower())


class PipelineExploit(BaseExploit):
    def __init__(self, exploit_configs):
        self.pipeline = []
        for exploit_config in exploit_configs:
            self.pipeline.append(exploit_factory.create(**exploit_config))

    def __call__(self, rng, trial, lineages):
        for exploit in self.pipeline:
            selected_trial = exploit(rng, trial, lineages)
            if selected_trial is not trial:
                return selected_trial

        return trial

    @property
    def configuration(self):
        configuration = super(PipelineExploit, self).configuration
        configuration["exploit_configs"] = [
            exploit.configuration for exploit in self.pipeline
        ]
        return configuration


class TruncateExploit(BaseExploit):
    def __init__(
        self,
        min_forking_population=5,
        truncation_quantile=0.8,
        candidate_pool_ratio=0.2,
    ):
        self.min_forking_population = min_forking_population
        self.truncation_quantile = truncation_quantile
        self.candidate_pool_ratio = candidate_pool_ratio

    def __call__(self, rng, trial, lineages):
        trials = lineages.get_trials_at_depth(trial)
        return self.truncate(rng, trial, trials)

    def truncate(
        self,
        rng,
        trial,
        trials,
    ):

        completed_trials = [trial for trial in trials if trial.status == "completed"]

        if len(completed_trials) < self.min_forking_population:
            return None

        if trial not in completed_trials:
            raise ValueError(
                f"Trial {trial.id} not included in list of completed trials."
            )

        sorted_trials = sorted(
            completed_trials, key=lambda trial: trial.objective.value
        )

        worse_trials = sorted_trials[
            int(self.truncation_quantile * len(sorted_trials)) :
        ]

        if trial not in worse_trials:
            return trial

        candidate_threshold_index = int(self.candidate_pool_ratio * len(sorted_trials))

        if candidate_threshold_index == 0:
            return None

        index = rng.choice(numpy.arange(0, candidate_threshold_index))
        return sorted_trials[index]

    @property
    def configuration(self):
        configuration = super(TruncateExploit, self).configuration
        configuration.update(
            dict(
                min_forking_population=self.min_forking_population,
                truncation_quantile=self.truncation_quantile,
                candidate_pool_ratio=self.candidate_pool_ratio,
            )
        )

        return configuration


class BacktrackExploit(TruncateExploit):
    """
    backtracking_tolerance: float, optional
        TODO: rewrite how backtracking_tolerance is used.

        If the objective drops by ``backtracking_tolerance``% from one fidelity to another,
        the lineage will be dropped and the candidate to select for forking will come from
        best trials so far (across all fidelity levels observed so far).
        Comes from [1]. Default: 0.2.

    [1] Zhang, Baohe, Raghu Rajan, Luis Pineda, Nathan Lambert, AndrÃ© Biedenkapp, Kurtland Chua,
    Frank Hutter, and Roberto Calandra. "On the importance of hyperparameter optimization for
    model-based reinforcement learning." In International Conference on Artificial Intelligence and
    Statistics, pp. 4015-4023. PMLR, 2021.
    """

    def __call__(self, rng, trial, lineages):
        # TODO: If we compare to elites at any fidelity, then we will likely always
        # jump from trials at low fidelity if we have less workers than population_size.
        # We should compare to same fidelity, but jump to any fidelity.
        # This should documented because it differs from Zhang's paper.
        # That's done with the max_depth=trial

        elites = lineages.get_elites(max_depth=trial)
        return self.truncate(rng, trial, elites + [trial])


exploit_factory = GenericFactory(BaseExploit)
